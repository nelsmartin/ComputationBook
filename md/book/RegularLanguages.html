<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Regular Languages - Theory of Computation in Lean</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Theory of Computation in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="regular-languages"><a class="header" href="#regular-languages">Regular Languages</a></h1>
<pre><code class="language-lean">import Mathlib.Data.Set.Basic
import Mathlib.Data.Matrix.Notation
import Mathlib.Data.Matrix.Basic

variable {α : Type*}
variable (A B : Set α)
open Set
</code></pre>
<p>Explain what finite automata are.</p>
<pre><code class="language-lean">universe u v

structure DFA (Q : Type u) (σ : Type v) where
  δ : Q → σ → Q
  q₀ : Q
  F : Set Q
</code></pre>
<p>Maybe some examples</p>
<pre><code class="language-lean">inductive state where
| q₁ : state
| q₂ : state

namespace state

def M₂ : DFA (state) (Fin 2) :=
⟨
  fun x s =&gt; match x with
  | q₁ =&gt; match s with | 0 =&gt; q₁ | 1 =&gt; q₂
  | q₂ =&gt; match s with | 0 =&gt; q₁ | 1 =&gt; q₂,
  q₁,
  {q₂}
⟩

end state


@[simp]
def accepts {Q : Type u} {σ : Type v} (M : DFA Q σ) (w : List σ) :=
  ∃ r : Fin (w.length + 1) → Q,
  (r 0 = M.q₀) ∧
  (∀ i : Fin (w.length), M.δ (r (i.castSucc)) w[i] = r (i.castSucc + 1)) ∧
  (r ⟨ w.length, by simp ⟩ ∈ M.F)



@[simp]
def run_DFA {Q : Type u} {σ : Type v} (M : DFA Q σ) (w : List σ) (steps : Fin (w.length + 1)): Q :=
  match steps with
  | 0 =&gt; M.q₀
  | ⟨ k + 1, h ⟩  =&gt;
    let h : k &lt; w.length + 1 := by omega
    M.δ (run_DFA M w ⟨ k, h ⟩) w[k]



def L_DFA {Q : Type u} {σ : Type v} (M : DFA Q σ) : Set (List σ) := {w | accepts M w}

universe w

def product_of_automata {Q₁ : Type u} {Q₂ : Type w} {σ : Type v} (M₁ : DFA Q₁ σ) (M₂ : DFA Q₂ σ) :
DFA (Q₁ × Q₂) σ :=
⟨
  fun (q₁, q₂) s =&gt; (M₁.δ q₁ s, M₂.δ q₂ s),
  (M₁.q₀, M₂.q₀),
  { (q₁, q₂) | (q₁ ∈ M₁.F) ∨ (q₂ ∈ M₂.F) }
⟩

def run_DFA1 {Q₁ : Type u} {Q₂ : Type w} {σ : Type v} (M₂ : DFA Q₂ σ) (w : List σ)
(r : Fin (w.length + 1) → Q₁) :
  Fin (w.length + 1) → Q₁ × Q₂ := fun x =&gt; (r x, run_DFA M₂ w x)

def run_DFA2 {Q₁ : Type u} {Q₂ : Type w} {σ : Type v} (M₁ : DFA Q₁ σ) (w : List σ)
(r : Fin (w.length + 1) → Q₂) :
  Fin (w.length + 1) → Q₁ × Q₂ := fun x =&gt; (run_DFA M₁ w x, r x)


theorem regular_languages_closed_under_union {Q₁ : Type u} {Q₂ : Type w} {σ : Type v}
(M₁ : DFA Q₁ σ)
(M₂ : DFA Q₂ σ) :
∃ Q : Type (max u w), ∃ M : DFA Q σ, L_DFA M = L_DFA M₁ ∪ L_DFA M₂ := by
  exists Q₁ × Q₂
  exists product_of_automata M₁ M₂
  rw[Subset.antisymm_iff,subset_def,subset_def,union_def]
  unfold product_of_automata
  constructor
  · intro w  ⟨ r, h_intro, h_trans, h_accept⟩
    unfold L_DFA accepts; simp; simp at h_intro h_trans h_accept
    cases h_accept with
    | inl hl =&gt;
      apply Or.inl
      exists fun x =&gt; (r x).1
      exact ⟨ by simp; rw[h_intro],
              by simp; intro i; rw[←h_trans],
              by simp; exact hl⟩
    | inr hr =&gt;
      apply Or.inr
      exists fun x =&gt; (r x).2
      exact ⟨ by simp; rw[h_intro],
              by simp; intro i; rw[←h_trans],
              by simp; exact hr⟩
  · unfold L_DFA accepts; simp
    intro w hw
    cases hw with
    | inl hl =&gt;
      obtain ⟨r, h_init, h_trans, h_accept⟩ := hl
      exists run_DFA1 M₂ w r
      unfold run_DFA1
      exact ⟨
        by unfold run_DFA; simp; exact ⟨ h_init, rfl ⟩,
        by intro i; simp; exact ⟨
          by exact h_trans i,
          by unfold run_DFA; conv =&gt; { rhs; unfold run_DFA; simp }; rfl
        ⟩,
        by apply Or.inl; simp; exact h_accept
      ⟩
    | inr hr =&gt;
      obtain ⟨r, h_init, h_trans, h_accept⟩ := hr
      exists run_DFA2 M₁ w r
      unfold run_DFA2
      exact ⟨
        by unfold run_DFA; simp; exact ⟨ rfl, h_init ⟩,
        by intro i; simp; exact ⟨
          by unfold run_DFA; conv =&gt; { rhs; unfold run_DFA; simp }; rfl,
          by exact h_trans i
        ⟩,
        by apply Or.inr; simp; exact h_accept⟩


structure NFA (Q : Type u) (σ : Type v) where
  δ : Q → σ → Set Q
  q₀ : Q
  F : Set Q

def accepts_NFA {Q : Type u} {σ : Type v} (M : NFA Q σ) (w : List σ) :=
  ∃ r : Fin (w.length + 1) → Q,
  (r 0 = M.q₀) ∧
  (∀ i : Fin w.length, r (i.castSucc + 1) ∈ M.δ (r i.castSucc) w[i]) ∧
  (r ⟨ w.length, by simp ⟩  ∈ M.F)


def L_NFA {Q : Type u} {σ : Type v} (M : NFA Q σ) : Set (List σ) :=
  {w | accepts_NFA M w}

@[simp]
 def run_NFA {Q : Type u} {σ : Type v}
 (M : NFA Q σ) (w : List σ) (steps : Fin (w.length + 1)) : Set Q :=
    match steps with
    | ⟨ 0, _ ⟩  =&gt; {M.q₀}
    | ⟨ k + 1, h ⟩ =&gt;
      let h : k &lt; w.length + 1 := by omega
      ⋃ r ∈ (run_NFA M w ⟨ k, h ⟩ ), M.δ r w[k]


def NFA_to_DFA {Q : Type u} {σ : Type v} (N : NFA Q σ) : DFA (Set Q) σ :=
  ⟨
    (fun R a =&gt; ⋃ r ∈ R, N.δ r a),
    ({N.q₀}),
    ({R | ∃ r ∈ R, r ∈ N.F})
  ⟩
</code></pre>
<p>Given that w ∈ L NFA, show that w ∈ L DFA using our run_DFA definition.
w ∈ L NFA means that there exists a series of states r where
(1) the first state is in start state of N,
(2) ∀ i, r (i + 1) ∈ N.δ (r i) w[i], and
(3) r (w.length) ∈ N.F.</p>
<pre><code>After the NFA has run, if any of the set of current states is ∈ N.F, the
word is accepted.

We need to prove that there is also an DFA that recognizes this same string.
We contructor our DFA as follows:

δ := fun (R : Set Q) (s : σ) → ⋃ r ∈ R, N.δ r s
q₀ := {N.q₀}
F := {(R : Set Q) | ∃ r ∈ R, r ∈ N.F}
</code></pre>
<p>The type of our DFA is Set Q. The delta function takes in a set of
states and a letter, and applies N.δ to each state in the set with
respect to that letter, each of which produces a set of states. These
sets of states are then all grouped into one happy set.</p>
<p>M.F is of type Set Set Q. F contains all of the sets of Q that contain
at least one of the states in N.F.</p>
<p>There are three criteria for the acceptance of a word by a DFA. I will lay
them out here and describe for each why the contruction of the DFA from the NFA
guarentees the satisfaction of that criteria.</p>
<p>where r i is defined as run_DFA M:</p>
<ol>
<li>r 0 = M.q₀
This is known because M.q₀ was set as {N.q₀}.</li>
</ol>
<pre><code>2. Delta

3. We know that the last state is a member of M.F because we are given that
   There exists a run of Q where each Q is a member of the set produced
   By ONE previous state and the previous symbol, and that the last
   state in the run is a member of the accept set of states.

   Therefore, because M.delta is merely combining the sets of states
   produced at each delta function, it is guaraneteed to include
   the run of N states. Therefore, At each step of M, the (r_DFA i) = R : Set Q must contain
   the r_NFA i = r : Q. And it follows that at the last step,
   the final Set Q must contain a state that was part of the origional accept state.
   Therefore, given that we defined the accept state of M as all of the sets that contain
   one of the accept states in N.F, the final Set Q in the DFA run is an accept state.




  Intermediate step: ∀ i, (r i) ∈ run_DFA M i
  Therefore, r (w.length) ∈ run_DFA M i*
  r (w.length) ∈ N.F
  run_DFA M i contains an N.F accept state
  that meets accept state criteria for M.
</code></pre>
<pre><code class="language-lean">theorem DFA_NFA_equivalence {Q : Type u} {σ : Type v} (N : NFA Q σ) :
∃ (Q' : Type u) (M : DFA Q' σ), L_DFA M = L_NFA N := by
  exists (Set Q)
  exists NFA_to_DFA N
  rw[Subset.antisymm_iff,subset_def,subset_def]
  constructor
  · intro w ⟨ r, h_init, h_trans, h_accept ⟩
    sorry
  · intro w ⟨ r, h_init, h_trans, h_accept ⟩
    unfold L_DFA accepts
    exists run_DFA (NFA_to_DFA N) w
    · unfold run_DFA NFA_to_DFA; simp
      exact ⟨
        by rfl,
        by intro i; conv =&gt; {rhs; unfold run_DFA; simp}; rfl,
        by
        exists r ⟨ w.length, by simp ⟩
        -- Two tasks: Prove that r : Q is accept state, and that it's in
        -- The final step of the M progression*.

        exact ⟨
          by
          let hx : ∀ i : Fin (w.length + 1), r i ∈ run_DFA (NFA_to_DFA N) w i := by
            unfold run_DFA NFA_to_DFA
            intro i
            induction i using Fin.induction with
            | zero=&gt; simp; rw[h_init]; rfl
            | succ i ih =&gt; simp; simp at ih; sorry



          sorry
          ,
          h_accept⟩ ,
      ⟩
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
